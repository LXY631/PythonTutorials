 -# 函数

## print 函数

- 默认输出并换行: `print("string")`
- 指定输出结束符: `print("string", end="__")`

## 自定义函数

``` PYTHON
def func_name():
  ...
  return None
````

- 形式参数(形参)
- 传递参数/实际参数(传参/实参)
- 返回值(注意：返回值得内存地址)
- 函数嵌套调用，必须顺序正确

- 位置参数：必须传值，且有几个参数就传几个传值
- 默认参数：没有传值，使用默认参数

- 形参：
  - `*args`: 元祖
  - `**kargs`: 字典

``` Python
func(1,2,3, a='a',b='b',c='c')
args = (1,2,3)
kargs = {a:'a',b:'b',c:'c'}

li = [1,2,3]
func(*li) # 实参角度，序列按照顺序打散

def func(*args): # 形参角度，给变量加上*，就是组合所有传来的值
'''
#     这个函数实现了什么功能
#     参数1：
#     参数2：
#     :return: 是字符串或者列表的长度
#     '''
```

- 形参：
  - 位置参数 ： 必须传
  - *args ：可以接收任意多个位置参数
  - 默认参数 ： 可以不传
  - **kwargs ： 可以接收多个关键字参数

- 实参：按照位置传参，按照关键字传参

- 默认函数参数的值是一个可变数据类型，那么每一次调用函数的时候，如果不传值就公用这个数据类型的资源

``` python
def fun(k, l={}):
  l[k] = 'v'
  print(l)

fun(1) # {1:'v'}
fun(2) # {1:'v',2:'v'}
fun(3) # {1:'v',2:'v',3:'v'}
```

## 命名空间和作用域

- 内置命名空间
  - Python解释器启动就可以使用的名字存储在内置命名空间中
  - 内置的名字在启动解释器的时候被加载进内存里
    - print()
    - input()
- 全局命名空间
  - 在程序从上到下被执行的过程中一次加载进内存的
  - 放置了我们设置的所有变量名和函数名
- 局部命名空间
  - 函数体内定义的名字
  - 调用函数的时候，才会产生这个名称空间，随着函数执行的结束，这个命名空间就消失

- 在局部:可以使用全局、内置命名空间中的名字
- 在全局:可以使用内置命名空间中的名字，但是不能用局部中使用
- 在内置:不能使用局部和全局的名字的

- globals()
- locals()
- global 关键字

局部调用：局部命名空间 < 全局命名空间 < 内置命名空间

全局调用：全局命名空间 < 内置命名空间

### nonlocal

只能用于局部变量，找上层中离当前函数最近一层的局部变量

声明了 nonlocal 的内部函数的变量修改会影响到里当前函数最近一层的局部变量

对全局无效

对局部也是对最近一层有影响

## return

函数里没有 return, 会默认返回一个 None

如果return多个对象，那么 Python 会把多个对象封装成一个元组作为一个一个整体结果输出

## 作用域

LEGB: Local < Enclosing < Global < Builtin

